[
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\mainCamera.cs",
    "relative_path": "mainCamera.cs",
    "file_name": "mainCamera.cs",
    "content": "using UnityEngine;\n\npublic class mainCamera : MonoBehaviour\n{\n    public LayerMask ignoreLayer;\n    public GameObject MouseImage;\n    public GameObject PowerRageBoundary;\n    public GameObject BallDirFlag;\n    public Camera cam;\n    GameObject robot;\n    // Start is called before the first frame update\n    void Start()\n    {\n        robot = GameObject.Find(Connect_Gate.team + \"_robot\" + Connect_Gate.robotID.ToString());\n        //robot = GameObject.Find(\"yellow_robot8\");\n\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        UnityEngine.Cursor.visible = false; // 隐藏鼠标\n        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hit;\n\n        // 使用 LayerMask 忽略特定图层\n        if (Physics.Raycast(ray, out hit, Mathf.Infinity, ~ignoreLayer))\n        {\n            MouseImage.transform.position = new Vector3(hit.point.x, 0.06f, hit.point.z);\n        }\n        Vector3 playerPos = robot.transform.position;\n        BallDirFlag.transform.position = robot.transform.position - (Vector3.up * 0.5f);\n        BallDirFlag.transform.LookAt(Vision.ball.transform);\n        BallDirFlag.transform.eulerAngles = new Vector3(90, BallDirFlag.transform.eulerAngles.y + 90, 0);\n\n\n\n        if (Vector3.Distance(Vision.ball.transform.position, playerPos) > Param.DRIBBLE_BALL_DISTANCE) \n        {\n            PowerRageBoundary.transform.position = robot.transform.position;\n        }\n        if (Input.GetKey(KeyCode.KeypadPlus) || Input.GetKey(KeyCode.Equals)) \n        {\n            transform.position += Vector3.up * 0.1f;\n        }\n        if (Input.GetKey(KeyCode.KeypadMinus) || Input.GetKey(KeyCode.Minus))\n        {\n            transform.position -= Vector3.up * 0.1f;\n        }\n\n        float speed = Vector3.Distance(transform.position, playerPos) > Param.CAMERA_SLOW_DISTANCE ? 5f * Time.deltaTime : 1.2f * Time.deltaTime;\n        transform.position = Vector3.Lerp(transform.position, new Vector3(playerPos.x, transform.position.y, playerPos.z), speed);\n\n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Connect\\Connect.cs",
    "relative_path": "Connect\\Connect.cs",
    "file_name": "Connect.cs",
    "content": "using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\nusing System.IO.Ports;\nusing TMPro;\nusing System;\nusing System.Linq;\nusing static Packet;\n\npublic class Connect : MonoBehaviour\n{\n    public TMP_Dropdown TeamDropdown;\n    public TMP_InputField RobotId_Input, Frequency_Input;\n    public TextMeshProUGUI SerialStatusText;\n    public TMP_Dropdown PortDropdown; // 更改为下拉菜单\n    public Button Connect_Button;\n\n    public int baudRate = 115200;\n    public Parity parity = Parity.None;\n    public int dataBits = 8;\n    public StopBits stopBits = StopBits.One;\n\n    static public SerialPort ser = null;\n    \n    void Start()\n    {\n        PopulatePortDropdown();\n        Connect_Button.onClick.AddListener(ButtonOnClickEvent);\n        //GameObject.Find(\"Connect_Button\").GetComponent<Button>().onClick.AddListener(ButtonOnClickEvent);\n\n    }\n\n    // 扫描可用串口并填充下拉菜单\n    private void PopulatePortDropdown()\n    {\n        PortDropdown.ClearOptions();\n        string[] ports = SerialPort.GetPortNames();\n        PortDropdown.AddOptions(ports.ToList());\n\n        if (ports.Length > 0)\n        {\n            PortDropdown.value = 0;\n            UpdateStatus($\"Status: Find {ports.Length} Port\");\n        }\n        else\n        {\n            UpdateStatus(\"Status: Not find port\");\n        }\n    }\n\n    // 尝试打开串口并返回成功状态\n    private bool OpenPort(string portName)\n    {\n        try\n        {\n            if (ser != null && ser.IsOpen)\n            {\n                ser.Close();\n            }\n\n            ser = new SerialPort(portName, baudRate, parity, dataBits, stopBits)\n            {\n                ReadTimeout = 500,\n                WriteTimeout = 500 // 添加写入超时设置\n            };\n\n            ser.Open();\n            if (ser.IsOpen)\n            {\n                UpdateStatus($\"成功连接 {portName}\");\n                return true;\n            }\n        }\n        catch (Exception ex)\n        {\n            UpdateStatus($\"连接失败: {ex.Message}\");\n        }\n        return false;\n    }\n\n    public void ButtonOnClickEvent()\n    {\n        Connect_Gate.team = TeamDropdown.options[TeamDropdown.value].text;\n        // 验证输入\n        if (!int.TryParse(RobotId_Input.text, out Connect_Gate.robotID))\n        {\n            UpdateStatus(\"无效的机器人ID\");\n            return;\n        }\n\n        if (!int.TryParse(Frequency_Input.text, out Connect_Gate.frequency))\n        {\n            UpdateStatus(\"无效的频率值\");\n            return;\n        }\n\n        // 获取选择的端口\n        string selectedPort = PortDropdown.options[PortDropdown.value].text;\n        if (string.IsNullOrEmpty(selectedPort))\n        {\n            UpdateStatus(\"请选择有效端口\");\n            return;\n        }\n\n        // 尝试打开端口\n        if (!OpenPort(selectedPort))\n        {\n\n            return;\n\n        }\n        // 准备并发送数据\n        Connect_Gate.packet = new RadioPacket(Connect_Gate.frequency);\n        ser.Write(Connect_Gate.packet.start_packet1, 0, Connect_Gate.packet.start_packet1.Length);\n        ser.BaseStream.Flush();\n        UpdateStatus($\"数据已发送至 {selectedPort}\");\n\n        float start_time = Time.time;\n        while (Time.time - start_time < 2)\n        {\n            if (ser.IsOpen && ser.BytesToRead > 0)\n            {\n                ser.ReadExisting();\n                break;\n            }\n            System.Threading.Thread.Sleep(10);\n        }\n        System.Threading.Thread.Sleep(2000);\n        ser.Write(Connect_Gate.packet.start_packet2, 0, Connect_Gate.packet.start_packet2.Length);\n        ser.BaseStream.Flush();\n\n        SceneManager.LoadScene(\"World\");\n\n    }\n\n    private void UpdateStatus(string message)\n    {\n        Debug.Log(message);\n        SerialStatusText.text = $\"{message}\";\n    }\n\n    void OnDestroy()\n    {\n        //if (ser != null && ser.IsOpen)\n        //{\n        //    ser.Close();\n        //    UpdateStatus(\"串口已关闭\");\n        //}\n    }\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Connect\\Connect_Client.cs",
    "relative_path": "Connect\\Connect_Client.cs",
    "file_name": "Connect_Client.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing UnityEngine.UI;\npublic class Connect_Client : MonoBehaviour\n{\n    public TMP_Dropdown TeamDropdown;\n    public TMP_InputField RobotId_Input, Frequency_Input, IP_Input, Port_Input;\n    public static string serverIP;\n    public static int serverPort;\n    public static int RobotID;\n    public static string frequency;\n    public Button Connect_Button;\n    // Start is called before the first frame update\n    void Start()\n    {\n        IP_Input = GameObject.Find(\"IP_Input\").GetComponent<TMP_InputField>();\n        Port_Input = GameObject.Find(\"Port_Input\").GetComponent<TMP_InputField>();\n        RobotId_Input = GameObject.Find(\"RobotId_Input\").GetComponent<TMP_InputField>();\n        Frequency_Input = GameObject.Find(\"Frequency_Input\").GetComponent<TMP_InputField>();\n        Connect_Button.onClick.AddListener(ButtonOnClickEvent);\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        \n    }\n    public void ButtonOnClickEvent()\n    {\n        Connect_Gate.IP = IP_Input.text;\n        int.TryParse(Port_Input.text, out Connect_Gate.Port);\n        int.TryParse(RobotId_Input.text, out Connect_Gate.robotID);\n        int.TryParse(Frequency_Input.text, out Connect_Gate.frequency);\n        Connect_Gate.team = TeamDropdown.options[TeamDropdown.value].text;\n        SceneManager.LoadScene(\"World\");\n    }\n\n\n    }\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Connect\\Connect_Gate.cs",
    "relative_path": "Connect\\Connect_Gate.cs",
    "file_name": "Connect_Gate.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing TMPro;\nusing UnityEngine;\nusing static Packet;\n\npublic class Connect_Gate : MonoBehaviour\n{\n    \n    public TMP_Dropdown ConnectMode;\n    public TMP_Dropdown GameMode;\n    public GameObject Serial_Mode;\n    public GameObject Socket_Mode;\n    static public string GAME_CONNECT_MODE;\n    static public string GAME_MODE;\n    static public int robotID = 0;\n    static public int frequency = 0;\n    static public int Port;\n    static public string IP;\n    static public string team = null;\n    static public RadioPacket packet = null;\n\n    void Start()\n    {\n        InitConnectModeDropdown();\n        InitGameModeDropdown();\n        UpdateModeVisibility();\n    }\n\n    private void InitConnectModeDropdown()\n    {\n        ConnectMode.ClearOptions();\n        ConnectMode.AddOptions(new List<string> { \"Serial\", \"Client\" });\n    }\n    private void InitGameModeDropdown()\n    {\n        GameMode.ClearOptions();\n        GameMode.AddOptions(new List<string> { \"Real\", \"Simulate\" });\n    }\n    private void Update()\n    {\n        UpdateModeVisibility();\n    }\n\n    private void UpdateModeVisibility()\n    {\n        Serial_Mode.SetActive(ConnectMode.options[ConnectMode.value].text == \"Serial\");\n        Socket_Mode.SetActive(ConnectMode.options[ConnectMode.value].text == \"Client\");\n        GAME_CONNECT_MODE = ConnectMode.options[ConnectMode.value].text;\n        Param.GAME_CONNECT_MODE = ConnectMode.options[ConnectMode.value].text;\n        GAME_MODE = GameMode.options[GameMode.value].text;\n        Param.GAME_MODE = GameMode.options[GameMode.value].text;\n    }\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Connect\\PacketSender.cs",
    "relative_path": "Connect\\PacketSender.cs",
    "file_name": "PacketSender.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing System.Runtime.ConstrainedExecution;\nusing UnityEngine;\nusing System;\nusing static Packet;\nusing System.Linq;\n\npublic class PacketSender : MonoBehaviour\n{\n    public UdpNetwork network;\n    void Start()\n    {   \n\n        network = GetComponent<UdpNetwork>();\n        if (Connect_Gate.GAME_CONNECT_MODE == \"Serial\")\n        {\n            \n            network.networkMode = UdpNetwork.Mode.Server;\n            // 添加空引用检查\n            if (network == null)\n            {\n                Debug.LogError(\"UdpNetwork component not found!\");\n                return;\n            }\n            network.OnMessageReceived += (message, ip) =>\n            {\n                int num = ReverseRealNum(message[1], message[2]);\n                Control.packet[num].transmitPacket = message;\n                Debug.Log($\"{num}\");\n            };\n        }\n        else if (Connect_Gate.GAME_CONNECT_MODE == \"Client\") \n        {\n            UdpNetwork network = GetComponent<UdpNetwork>();\n            network.networkMode = UdpNetwork.Mode.Client;\n            network.serverIP = Connect_Gate.IP;\n            network.serverPort = Connect_Gate.Port; \n\n            if (network == null)\n            {\n                Debug.LogError(\"UdpNetwork component not found!\");\n                return;\n            }\n\n        }\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        if (Connect_Gate.GAME_CONNECT_MODE == \"Serial\") \n        {\n            send_all_packet_server();\n        }\n        else if (Connect_Gate.GAME_CONNECT_MODE == \"Client\")\n        {\n            network.Send(Control.packet[Connect_Gate.robotID].transmitPacket);\n            System.Threading.Thread.Sleep(3);\n        }\n    }\n    static public void send_all_packet_server()\n    {\n\n        for (int i = 0; i < Control.packet.Length; i++)\n        {\n            bool areEqual = Control.packet[i].transmitPacket.SequenceEqual(new byte[Constants.TRANSMIT_PACKET_SIZE]);\n            if (!areEqual)\n            {\n                //Debug.Log($\"{packet[i].transmitPacket}\");\n                Connect.ser.Write(Control.packet[i].transmitPacket, 0, Control.packet[i].transmitPacket.Length);\n                Connect.ser.BaseStream.Flush();\n                System.Threading.Thread.Sleep(1);\n                Control.packet[i].transmitPacket = new byte[Constants.TRANSMIT_PACKET_SIZE];\n            }\n        }\n    }\n    public static int ReverseRealNum(byte txbuff1, byte txbuff2)\n    {\n        // 检查 TXBuff[1] 是否有置位\n        for (int bitPos = 0; bitPos < 8; bitPos++)\n        {\n            int mask = 0x01 << bitPos;\n            if ((txbuff1 & mask) != 0)\n            {\n                // 发现置位，检查 TXBuff[2] 是否为 0\n                if (txbuff2 != 0)\n                {\n                    return 0; // 冲突，无法唯一确定\n                }\n                return 8 + bitPos; // real_num = 8 + 位位置\n            }\n        }\n\n        // 检查 TXBuff[2] 是否有置位\n        for (int bitPos = 0; bitPos < 8; bitPos++)\n        {\n            int mask = 0x01 << bitPos;\n            if ((txbuff2 & mask) != 0)\n            {\n                // 发现置位，检查 TXBuff[1] 是否为 0\n                if (txbuff1 != 0)\n                {\n                    return 0; // 冲突，无法唯一确定\n                }\n                return bitPos; // real_num = 位位置\n            }\n        }\n        return 0;\n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Connect\\UdpNetwork.cs",
    "relative_path": "Connect\\UdpNetwork.cs",
    "file_name": "UdpNetwork.cs",
    "content": "using UnityEngine;\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing System.Collections.Generic;\n\npublic class UdpNetwork : MonoBehaviour\n{\n    public enum Mode { Server, Client }\n\n    public Mode networkMode = Mode.Server;\n\n    // Server settings\n    public int serverPort = 16701;\n\n    // Client settings\n    public string serverIP = \"172.20.64.232\";\n    public int clientTargetPort = 16701;\n\n    private UdpClient udpClient;\n    private IPEndPoint targetEndPoint;\n    private Thread receiveThread;\n    private bool isRunning;\n    public event Action<byte[], string> OnMessageReceived; // (message, sourceIP)\n\n    void Start()\n    {\n        serverIP = Connect_Gate.IP;\n        clientTargetPort = Connect_Gate.Port;\n\n        Loom.Initialize(); // 添加这行初始化代码\n        if (Connect_Gate.GAME_CONNECT_MODE == \"Serial\")\n        {\n            networkMode = Mode.Server;\n            InitializeServer();\n        }\n        else if (Connect_Gate.GAME_CONNECT_MODE == \"Client\")\n        {\n            networkMode = Mode.Client;\n            InitializeClient();\n        }\n\n    }\n\n    private void InitializeServer()\n    {\n        // Bind to 0.0.0.0 to listen on all interfaces\n        udpClient = new UdpClient(new IPEndPoint(IPAddress.Parse(\"0.0.0.0\"), serverPort));\n        isRunning = true;\n        receiveThread = new Thread(ServerReceive);\n        receiveThread.Start();\n    }\n\n    private void InitializeClient()\n    {\n        udpClient = new UdpClient(0);\n        //udpClient.EnableBroadcast = true; // 如果需要广播可开启\n        Debug.Log($\"Sent {serverIP} bytes to {clientTargetPort}\");\n\n        targetEndPoint = new IPEndPoint(IPAddress.Parse(serverIP), clientTargetPort);\n        Debug.Log($\"Sent {serverIP} bytes to {clientTargetPort}\");\n    }\n\n    private void ServerReceive()\n    {\n        while (isRunning)\n        {\n            try\n            {\n                IPEndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                byte[] data = udpClient.Receive(ref remoteEndPoint);\n                //string message = Encoding.UTF8.GetString(data);\n\n                // Unity主线程执行\n                Loom.QueueOnMainThread(() =>\n                {\n                    OnMessageReceived?.Invoke(data, remoteEndPoint.Address.ToString());\n                });\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"Receive error: {e.Message}\");\n            }\n        }\n    }\n\n    public void Send(byte[] message)\n    {\n        if (networkMode != Mode.Client)\n        {\n            Debug.LogWarning(\"Only client can send messages\");\n            return;\n        }\n\n        try\n        {\n            udpClient.Send(message, message.Length, targetEndPoint);\n            //Debug.Log($\"Sent {message.Length} bytes to {targetEndPoint}\");\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Send error: {e.Message}\");\n        }\n    }\n\n    void OnDestroy()\n    {\n        isRunning = false;\n        udpClient?.Close();\n        receiveThread?.Abort();\n    }\n}\n\n// 需要在项目中添加Loom.cs用于多线程回调\npublic class Loom : MonoBehaviour\n{\n    private static Loom _instance;\n\n    public static void Initialize()\n    {\n        if (_instance == null)\n        {\n            _instance = new GameObject(\"Loom\").AddComponent<Loom>();\n            DontDestroyOnLoad(_instance.gameObject);\n        }\n    }\n\n    public static void QueueOnMainThread(Action action)\n    {\n        lock (_actions)\n        {\n            _actions.Add(action);\n        }\n    }\n\n    private static List<Action> _actions = new List<Action>();\n    private List<Action> _currentActions = new List<Action>();\n\n    void Update()\n    {\n        lock (_actions)\n        {\n            _currentActions.Clear();\n            _currentActions.AddRange(_actions);\n            _actions.Clear();\n        }\n\n        foreach (var action in _currentActions)\n        {\n            action();\n        }\n    }\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Control\\Control.cs",
    "relative_path": "Control\\Control.cs",
    "file_name": "Control.cs",
    "content": "using System;\nusing System.Linq;\nusing UnityEngine;\nusing static Packet;\n\npublic class Control : MonoBehaviour\n{\n    int control_robot_id = Connect_Gate.robotID;\n    int control_frequency = Connect_Gate.frequency;\n    string control_team = Connect_Gate.team;\n    string game_mode = Connect_Gate.GAME_MODE;\n    public GameObject targetObj;\n    static public RadioPacket[] packet = new RadioPacket[16];\n\n    public float selfVx = 0;\n    public float selfVy = 0;\n    public float selfVr = 0;\n    public float selfPower = 0;\n\n    public float maxRotationOutput = 500f; // 最大旋转输出值\n\n    void Start()\n    {\n        \n        System.Threading.Thread.Sleep(1000);\n        if (game_mode == Param.SIMULATE) \n        {\n            packet = Control_Sim.packet;\n        }\n        else if (game_mode == Param.REAL)\n        {\n            packet = Control_Real.packet;\n        }\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        float[] localVelocities = Control_Utils.GlobalToLocalVelocity(Vision.selfRobot,packet[control_robot_id].velX, packet[control_robot_id].velY, packet[control_robot_id].useGlobleVel);\n        packet[control_robot_id].velX = localVelocities[0];\n        packet[control_robot_id].velY = localVelocities[1];\n        packet[control_robot_id].Encode();\n    }\n    \n\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Control\\Control_Model.cs",
    "relative_path": "Control\\Control_Model.cs",
    "file_name": "Control_Model.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Control_Model : MonoBehaviour\n{\n\n    public Vector3 NextPosition(GameObject robot, float vx, float vy) \n    {\n        float deltaX = vx * Time.deltaTime;\n        float deltaY = vy * Time.deltaTime;\n        Vector3 robotPostion = robot.transform.position;\n        Vector3 nextPosition = new UnityEngine.Vector3(robotPostion.x + deltaX, robotPostion.y, robotPostion.z + deltaY);\n        return nextPosition;\n    }\n\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        \n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Control\\Control_Real.cs",
    "relative_path": "Control\\Control_Real.cs",
    "file_name": "Control_Real.cs",
    "content": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing static Packet;\n\npublic class Control_Real : MonoBehaviour\n{\n    static int control_robot_id = Connect_Gate.robotID;\n    static int control_frequency = Connect_Gate.frequency;\n    static string control_team = Connect_Gate.team;\n    static public GameObject targetObj;\n    static public GameObject nearMouseObj;\n    static public float selfVx = 0;\n    static public float selfVy = 0;\n    static public float selfVr = 0;\n    static public float selfPower = 0;\n    static public float maxRotationOutput = 500f; // 最大旋转输出值\n    static public PIDRotation pid = new PIDRotation();\n    static public RadioPacket[] packet = new RadioPacket[16];\n    public void Awake()\n    {\n        if (Param.GAME_MODE != Param.REAL) return;\n\n        for (int i = 0; i < packet.Length; i++)\n        {\n            packet[i] = new RadioPacket(control_frequency); // 或者使用不同的参数，根据你的需求\n            packet[i].robotID = i;\n        }\n        pid.P = 3.5f;\n        pid.I = 0.01f;\n        pid.D = 0.01f;\n        System.Threading.Thread.Sleep(1000);\n        targetObj = Vision.mouseObj;\n    }\n\n    // Update is called once per frame\n    public void Update()\n    {\n        if (Param.GAME_MODE != Param.REAL) return;\n        resetPacket();\n        ProcessInput();\n        packet[control_robot_id].velR = Control_Utils.RotateTowardsTarget(Vision.selfRobot, targetObj.transform.position, pid, Param.REAL);\n\n    }\n    public void ProcessInput()\n    {\n\n        if (Input.GetKey(KeyCode.S))\n        {\n            selfVx = 50;\n        }\n        if (Input.GetKey(KeyCode.W))\n        {\n            selfVx = -50;\n        }\n        if (Input.GetKey(KeyCode.D))\n        {\n            selfVy = -50;\n        }\n        if (Input.GetKey(KeyCode.A))\n        {\n            selfVy = 50;\n        }\n        if (Input.GetKey(KeyCode.LeftShift))\n        {\n            selfVx = selfVx != 0 ? Math.Sign(selfVx) * 255 : 0;\n            selfVy = selfVy != 0 ? Math.Sign(selfVy) * 255 : 0;\n        }\n        if (Input.GetMouseButton(1))\n        {\n            packet[control_robot_id].ctrl = true;\n        }\n        if (Input.GetMouseButton(0))\n        {\n            packet[control_robot_id].shootPowerLevel = Control_Utils.PowerSet((targetObj.transform.position - Vision.selfRobot.transform.position).magnitude);\n            packet[control_robot_id].shoot = true;\n        }\n\n        if (Input.GetMouseButton(2))\n        {\n            nearMouseObj = Vision.FindNearestObjectInRange(Vision.mouseObj.transform.position, 1.5f);\n            nearMouseObj = nearMouseObj == null ? Vision.mouseObj : nearMouseObj;\n            targetObj = nearMouseObj;\n        }\n        packet[control_robot_id].velX = selfVx;\n        packet[control_robot_id].velY = selfVy;\n\n\n    }\n    public void resetPacket()\n    {\n        packet[control_robot_id].resetPacket(control_robot_id, control_frequency);\n        selfVx = 0;\n        selfVy = 0;\n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Control\\Control_Sim.cs",
    "relative_path": "Control\\Control_Sim.cs",
    "file_name": "Control_Sim.cs",
    "content": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEditor;\nusing UnityEngine;\nusing static Packet;\nusing static UnityEngine.GraphicsBuffer;\n\npublic class Control_Sim : MonoBehaviour\n{\n    public GameObject PowerRageBoundary;\n    static public float targetVx = 0;\n    static public float targetVy = 0;\n    static public float acceleration = 80f;   // 加速度（单位/秒²）\n    static public float deceleration = 400f;   // 减速度（单位/秒²）\n\n    static int control_robot_id = Connect_Gate.robotID;\n    static int control_frequency = Connect_Gate.frequency;\n    static string control_team = Connect_Gate.team;\n    static public GameObject targetObj;\n    static public GameObject nearMouseObj;\n    static public float selfVx = 0;\n    static public float selfVy = 0;\n    static public float selfVr = 0;\n    static public float selfPower = 0;\n    static public float maxRotationOutput = 500f; // 最大旋转输出值\n    static public PIDRotation pid = new PIDRotation();\n    static public RadioPacket[] packet = new RadioPacket[16];\n\n    RuntimeLineRenderer line;\n\n\n    \n    public void Awake()\n    {\n        if (Param.GAME_MODE != Param.SIMULATE) return;\n\n        for (int i = 0; i < packet.Length; i++)\n        {\n            packet[i] = new RadioPacket(control_frequency); // 或者使用不同的参数，根据你的需求\n            packet[i].robotID = i;\n        }\n        pid.P = 7.85f;\n        pid.I = 0.03f;\n        pid.D = 0.5f;\n        System.Threading.Thread.Sleep(100);\n        targetObj = Vision.mouseObj;\n        line = gameObject.AddComponent<RuntimeLineRenderer>();\n\n    }\n\n    // Update is called once per frame\n    public void Update()\n    {\n        if (Param.GAME_MODE != Param.SIMULATE) return;\n        resetPacket();\n        ProcessInput();\n        autoShoot();\n        auto_unlock_ball();\n\n        float deltaTime = Time.deltaTime;\n        UpdateVelocity(ref selfVx, targetVx, deltaTime);\n        UpdateVelocity(ref selfVy, targetVy, deltaTime);\n\n        line.UpdateExtendedLineWithAngle(Vision.selfRobot.transform.position + Vector3.up * 0.01f, Vision.selfRobot.transform.eulerAngles.y, 80f);\n        packet[control_robot_id].velR = Control_Utils.RotateTowardsTarget(Vision.selfRobot, targetObj.transform.position, pid,Param.SIMULATE);\n        packet[control_robot_id].velX = selfVx;\n        packet[control_robot_id].velY = selfVy;\n\n    }\n\n    public void auto_unlock_ball() \n    {\n        if (Vector3.Distance(Vision.ball.transform.position, Vision.selfRobot.transform.position) <= Param.DRIBBLE_BALL_DISTANCE) \n        {\n            targetObj = Vision.mouseObj;\n        }\n\n    }\n\n    \n    private void UpdateVelocity(ref float current, float target, float deltaTime)\n    {\n        if (Mathf.Approximately(target, 0))\n        {\n            // 当没有输入时使用减速度\n            current = Mathf.MoveTowards(current, 0, deceleration * deltaTime);\n        }\n        else\n        {\n            // 根据目标方向使用加速度\n            float accelerateDirection = Mathf.Sign(target);\n            if (Mathf.Approximately(current, 0) || Mathf.Sign(current) == accelerateDirection)\n            {\n                // 同方向加速\n                current = Mathf.MoveTowards(current, target, acceleration * deltaTime);\n            }\n            else\n            {\n                // 反向时先快速减速\n                current = Mathf.MoveTowards(current, 0, deceleration * 2 * deltaTime);\n            }\n        }\n    }\n    public void autoShoot() \n    {\n        float distance = Vector3.Distance(Vision.ball.transform.position, PowerRageBoundary.transform.position);\n        if (distance > 8.2)\n        {\n            packet[control_robot_id].shootMode = false;\n            packet[control_robot_id].shootPowerLevel = Control_Utils.PowerSet(2);\n            packet[control_robot_id].shoot = true;\n        }\n\n    }\n    public void ProcessInput()\n    {\n        // 初始化目标速度为0\n        targetVx = 0;\n        targetVy = 0;\n\n        // 键盘输入处理\n        if (Input.GetKey(KeyCode.D)) targetVx = Param.NROMAL_SPEED;\n        if (Input.GetKey(KeyCode.A)) targetVx = -Param.NROMAL_SPEED;\n        if (Input.GetKey(KeyCode.W)) targetVy = -Param.NROMAL_SPEED;\n        if (Input.GetKey(KeyCode.S)) targetVy = Param.NROMAL_SPEED;\n\n        // 速度模式切换\n        if (Input.GetKey(KeyCode.LeftShift))\n        {\n            targetVx = targetVx != 0 ? Mathf.Sign(targetVx) * Param.MAX_SPEED : 0;\n            targetVy = targetVy != 0 ? Mathf.Sign(targetVy) * Param.MAX_SPEED : 0;\n        }\n        else if (Input.GetKey(KeyCode.LeftControl))\n        {\n            targetVx = targetVx != 0 ? Mathf.Sign(targetVx) * Param.SLOW_SPEED : 0;\n            targetVy = targetVy != 0 ? Mathf.Sign(targetVy) * Param.SLOW_SPEED : 0;\n        }\n\n        if (Input.GetKey(KeyCode.Space))\n        {\n            targetVy = -1 * targetVy;\n            packet[control_robot_id].useGlobleVel = false;\n        \n        }\n            \n        if (Input.GetMouseButton(1))\n        {\n            packet[control_robot_id].ctrl = true;\n        }\n        if (Input.GetKey(KeyCode.LeftControl) && Input.GetMouseButton(0))\n        {\n\n            packet[control_robot_id].shootMode = true;\n            packet[control_robot_id].shootPowerLevel = Control_Utils.PowerSet((targetObj.transform.position - Vision.selfRobot.transform.position).magnitude);\n            packet[control_robot_id].shoot = true;\n        }\n        else if (Input.GetMouseButton(0)) \n        {\n            packet[control_robot_id].shootMode = false;\n            packet[control_robot_id].shootPowerLevel = Control_Utils.PowerSet((targetObj.transform.position - Vision.selfRobot.transform.position).magnitude);\n            packet[control_robot_id].shoot = true;\n            if (Geometry.LinesIntersect((Vision.selfRobot.transform.position).ToVector2(), (Vision.mouseObj.transform.position).ToVector2(), new Vector2(45, 5), new Vector2(45, -5)) ||\n                Geometry.LinesIntersect((Vision.selfRobot.transform.position).ToVector2(), (Vision.mouseObj.transform.position).ToVector2(), new Vector2(-45, 5), new Vector2(-45, -5)))\n            {\n                packet[control_robot_id].shootPowerLevel = Control_Utils.PowerSet(99999);\n            }\n            else\n            {\n                packet[control_robot_id].shootPowerLevel = Control_Utils.PowerSet((targetObj.transform.position - Vision.selfRobot.transform.position).magnitude);\n            }\n\n        }\n        if (Input.GetMouseButton(2)) \n        {\n            nearMouseObj = Vision.FindNearestObjectInRange(Vision.mouseObj.transform.position, 2f);\n            nearMouseObj = nearMouseObj == null ? Vision.mouseObj : nearMouseObj;\n            targetObj = nearMouseObj;\n        }\n\n        packet[control_robot_id].velX = selfVx;\n        packet[control_robot_id].velY = selfVy;\n        \n\n    }\n    public void resetPacket()\n    {\n        packet[control_robot_id].resetPacket(control_robot_id, control_frequency);\n\n        //selfVx = 0;\n        //selfVy = 0;\n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Control\\Control_Utils.cs",
    "relative_path": "Control\\Control_Utils.cs",
    "file_name": "Control_Utils.cs",
    "content": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\npublic class Control_Utils : MonoBehaviour\n{\n\n    static public float RotateTowardsTarget(GameObject robot, UnityEngine.Vector3 target_pos,PIDRotation pid ,string game_mode,float maxRotationOutput = 500)\n    {\n        Vector3 toTarget = game_mode == Param.SIMULATE ? - (robot.transform.position - target_pos): robot.transform.position - target_pos; \n        toTarget.y = 0;\n        if (toTarget.sqrMagnitude < 0.001f) return 0;\n        toTarget.Normalize();\n\n        Vector3 robotForward = game_mode == Param.SIMULATE?robot.transform.rotation * Vector3.back: robot.transform.forward;\n        robotForward.Normalize();\n\n        float angleDiff = Vector3.SignedAngle(robotForward, toTarget, Vector3.up);\n        angleDiff = game_mode == Param.SIMULATE ?-1* angleDiff: angleDiff;\n        float rotationOutput = pid.Compute(angleDiff, Time.deltaTime);\n\n        rotationOutput = Mathf.Clamp(rotationOutput, -maxRotationOutput, maxRotationOutput);\n\n        robotForward = game_mode == Param.SIMULATE ? robot.transform.rotation * Vector3.back : robot.transform.forward;\n        robotForward.Normalize();\n        angleDiff = Vector3.SignedAngle(robotForward, toTarget, Vector3.up);\n        if (Mathf.Abs(angleDiff) < 0.5f) return 0;\n        return rotationOutput;\n    }\n\n\n    static public float[] GlobalToLocalVelocity(GameObject robot, float global_vx, float global_vy,bool is_use = true)\n    {\n        if (!is_use) return new float[] { global_vx, global_vy };\n        // 1. 获取机器人的全局旋转\n        float theta_w = robot.transform.eulerAngles[1] * Mathf.Deg2Rad; // Convert to radians\n        float local_vx = global_vx * Mathf.Cos(theta_w) + global_vy * Mathf.Sin(theta_w);\n        float local_vy = -global_vx * Mathf.Sin(theta_w) + global_vy * Mathf.Cos(theta_w);\n        // 6. 返回局部速度数组\n        return new float[] { local_vx, local_vy };\n    }\n     \n    static public float PowerSet(float dist, float rate = 0.088f, float min = 5, float max = 255)\n    {\n\n        // 检查输入参数的有效性\n        if (dist <= 0 || min >= max || rate <= 0)\n        {\n            return min; // 或者返回一个错误值，例如 NaN\n        }\n\n        // 计算比例因子，确保结果在 [0, 1] 范围内\n        float proportion = 1.0f - (float)Math.Exp(-dist * rate); // 使用指数函数，确保比例在 0 到 1 之间\n        proportion = Math.Max(0.0f, Math.Min(1.0f, proportion)); // 限制比例在 [0, 1] 范围内\n\n        // 使用比例因子在最小值和最大值之间进行插值\n        return min + proportion * (max - min);\n    }\n\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Debug\\RuntimeLineRenderer.cs",
    "relative_path": "Debug\\RuntimeLineRenderer.cs",
    "file_name": "RuntimeLineRenderer.cs",
    "content": "using UnityEngine;\n\npublic class RuntimeLineRenderer : MonoBehaviour\n{\n    public Material lineMaterial; // 使用默认材质或自定义材质\n    private LineRenderer lineRenderer;\n\n    void Start()\n    {\n        // 创建LineRenderer组件\n        lineRenderer = gameObject.AddComponent<LineRenderer>();\n        lineRenderer.material = lineMaterial;\n        lineRenderer.startColor = Color.red;\n        lineRenderer.endColor = Color.red;\n        lineRenderer.startWidth = 0.1f;\n        lineRenderer.endWidth = 0.1f;\n        lineRenderer.positionCount = 2;\n    }\n\n    // 动态更新起点和终点（例如在Update中）\n    public void UpdatePoints(Vector3 start, Vector3 end)\n    {\n        lineRenderer.SetPosition(0, start);\n        lineRenderer.SetPosition(1, end);\n    }\n    public void UpdateExtendedLine(Vector3 start, Vector3 originalEnd, float totalLength)\n    {\n        \n        Vector3 p2 = start;\n        Vector3 direction = originalEnd - start;\n\n        Vector3 unitDirection = direction;\n        p2 = start + unitDirection * totalLength;\n        p2.y = start.y;\n        UpdatePoints(start, p2); \n    }\n\n    public void UpdateExtendedLineWithAngle(Vector3 start, float yRotationAngle, float totalLength)\n    {\n        // 将绕Y轴的旋转角度转换为方向向量（XZ平面）\n        Vector3 direction = Quaternion.Euler(0, yRotationAngle, 0) * Vector3.back;\n\n        // 计算终点位置\n        Vector3 endPoint = start + direction * totalLength;\n\n        // 保持终点Y轴与起点一致（可选，根据需求决定是否保留）\n        endPoint.y = start.y;\n\n        // 更新线段渲染\n        UpdatePoints(start, endPoint);\n    }\n\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Geometry\\Geometry.cs",
    "relative_path": "Geometry\\Geometry.cs",
    "file_name": "Geometry.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Geometry : MonoBehaviour\n{\n\n\n\n\n    public static bool LinesIntersect(Vector2 line1Start, Vector2 line1End, Vector2 line2Start, Vector2 line2End)\n    {\n        // 计算方向向量\n        Vector2 dir1 = line1End - line1Start;\n        Vector2 dir2 = line2End - line2Start;\n\n        // 计算叉乘\n        float cross = dir1.x * dir2.y - dir1.y * dir2.x;\n\n        // 如果叉乘为0，说明直线平行\n        if (Mathf.Approximately(cross, 0f))\n            return false;\n\n        // 计算参数t和u\n        Vector2 v = line2Start - line1Start;\n        float t = (v.x * dir2.y - v.y * dir2.x) / cross;\n        float u = (v.x * dir1.y - v.y * dir1.x) / cross;\n\n        // 判断交点是否在两条线段上\n        return t >= 0 && t <= 1 && u >= 0 && u <= 1;\n    }\n\n    public static Vector2 GetProjectionPoint2D(Vector2 point, Vector2 lineStart, Vector2 lineEnd)\n    {\n        // 计算直线方向向量\n        Vector2 lineDirection = lineEnd - lineStart;\n\n        // 计算点到线起点的向量\n        Vector2 pointToLineStart = point - lineStart;\n\n        // 计算投影长度\n        float projectionLength = Vector2.Dot(pointToLineStart, lineDirection) / lineDirection.sqrMagnitude;\n\n        // 计算投影点\n        Vector2 projectionPoint = lineStart + projectionLength * lineDirection;\n\n        return projectionPoint;\n    }\n}\n\npublic static class Vector3Extensions\n{\n    // 转换为2D向量（保留X和Y）\n    public static Vector2 ToVector2(this Vector3 vector)\n    {\n        return new Vector2(vector.x, vector.y);\n    }\n\n    // 可选：指定保留哪个平面\n    public static Vector2 ToVector2(this Vector3 vector, Plane plane)\n    {\n        switch (plane)\n        {\n            case Plane.XY:\n                return new Vector2(vector.x, vector.y);\n            case Plane.XZ:\n                return new Vector2(vector.x, vector.z);\n            case Plane.YZ:\n                return new Vector2(vector.y, vector.z);\n            default:\n                return new Vector2(vector.x, vector.y);\n        }\n    }\n\n    // 枚举定义\n    public enum Plane\n    {\n        XY,\n        XZ,\n        YZ\n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Packet\\ccrc.cs",
    "relative_path": "Packet\\ccrc.cs",
    "file_name": "ccrc.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System;\n\npublic class ccrc : MonoBehaviour\n{\n    // Start is called before the first frame update\n\n    public class CCrc8\n    {\n        private static readonly byte[] crc8Table = {\n        0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83,\n        0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41,\n        0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e,\n        0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc,\n        0x23, 0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0,\n        0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62,\n        0xbe, 0xe0, 0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d,\n        0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff,\n        0x46, 0x18, 0xfa, 0xa4, 0x27, 0x79, 0x9b, 0xc5,\n        0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07,\n        0xdb, 0x85, 0x67, 0x39, 0xba, 0xe4, 0x06, 0x58,\n        0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a,\n        0x65, 0x3b, 0xd9, 0x87, 0x04, 0x5a, 0xb8, 0xe6,\n        0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24,\n        0xf8, 0xa6, 0x44, 0x1a, 0x99, 0xc7, 0x25, 0x7b,\n        0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9,\n        0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f,\n        0x4e, 0x10, 0xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd,\n        0x11, 0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92,\n        0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50,\n        0xaf, 0xf1, 0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c,\n        0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee,\n        0x32, 0x6c, 0x8e, 0xd0, 0x53, 0x0d, 0xef, 0xb1,\n        0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73,\n        0xca, 0x94, 0x76, 0x28, 0xab, 0xf5, 0x17, 0x49,\n        0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b,\n        0x57, 0x09, 0xeb, 0xb5, 0x36, 0x68, 0x8a, 0xd4,\n        0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x16,\n        0xe9, 0xb7, 0x55, 0x0b, 0x88, 0xd6, 0x34, 0x6a,\n        0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8,\n        0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7,\n        0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35\n    };\n\n        public static byte Calc(byte[] buffer, int length)\n        {\n            byte fcs = 0;\n            for (int i = 0; i < length; i++)\n            {\n                fcs = ClacFcs(fcs, buffer[i]);\n            }\n            return fcs;\n        }\n\n        private static byte ClacFcs(byte fcs, byte c)\n        {\n            return crc8Table[fcs ^ c];\n        }\n    }\n\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Packet\\packet.cs",
    "relative_path": "Packet\\packet.cs",
    "file_name": "packet.cs",
    "content": "using Google.Protobuf;\nusing System;\nusing System.Drawing.Imaging;\nusing TMPro;\nusing UnityEngine;\nusing static ccrc;\n\npublic class Packet : MonoBehaviour\n{\n    public class Constants\n    {\n        public const int TRANSMIT_PACKET_SIZE = 25;\n        public const int TRANS_FEEDBACK_SIZE = 20;\n    }\n\n    public class Command\n    {\n        public float power = 0.0f;\n        public float dribble = 0.0f;\n        public float vx = 0.0f;\n        public float vy = 0.0f;\n        public float vr = 0.0f;\n        public int id = 0;\n        public bool valid = false;\n        public bool kick_mode = false;\n    }\n\n    public class RadioPacket\n    {\n        public TMP_Dropdown gameMode_obj;\n        public int robotID = 0;\n        public float velX = 0.0f;\n        public float velY = 0.0f;\n        public float velR = 0.0f;\n        public bool useGlobleVel = true;\n        public bool ctrl = false;\n        public float ctrlPowerLevel = 3.0f;\n        public bool shoot = false;\n        public float shootPowerLevel = 0.0f;\n        public bool shootMode = false;\n        public int frequency;\n        public byte[] transmitPacket;\n        public byte[] start_packet1;\n        public byte[] start_packet2;\n\n        public RadioPacket(int frequency)\n        {\n            this.frequency = frequency;\n            this.transmitPacket = new byte[Constants.TRANSMIT_PACKET_SIZE];\n            CreateStartPacket(frequency, out this.start_packet1, out this.start_packet2);\n        }\n\n        public byte[] Encode_Radio()\n        {\n            Command HU_CMD = new Command();\n            HU_CMD.valid = true;\n            HU_CMD.id = this.robotID;\n            HU_CMD.vx = this.velX;\n            HU_CMD.vy = this.velY;\n            HU_CMD.vr = this.velR;\n            HU_CMD.dribble = this.ctrl ? this.ctrlPowerLevel : 0;\n            HU_CMD.power = this.shoot ? this.shootPowerLevel : 0;\n            HU_CMD.kick_mode = this.shootMode;\n\n            Array.Clear(this.transmitPacket, 0, this.transmitPacket.Length);\n            this.transmitPacket[0] = 0xFF;\n            this.transmitPacket[21] = (byte)(((this.frequency & 0x0F) << 4) | 0x07);\n\n            EncodeLegacy(HU_CMD, this.transmitPacket, 0);\n            return this.transmitPacket;\n        }\n\n        public byte[] Encode_grSim() \n        {\n            grSim_Packet grSimPacket = new grSim_Packet();\n\n            var commands = new grSim_Commands\n            {\n                Timestamp = 0,\n                Isteamyellow = Connect_Gate.team == \"yellow\" ? true : false\n            };\n            var robotCommand = new grSim_Robot_Command\n            {\n                Id = (uint)this.robotID,\n                Kickspeedx = this.shoot ? this.shootPowerLevel / Param.MAX_POWER * 6.3f : 0.0f,\n                Kickspeedz = this.shootMode ? this.shootPowerLevel / Param.MAX_POWER * 6.3f : 0.0f,\n                Veltangent = this.velY / 255 * 4,\n                Velnormal = this.velX / 255 * 4,\n                Velangular = this.velR / 500 * 8.5f,\n                Spinner = this.ctrl,\n                Wheelsspeed = false,\n                Wheel1 = 0.0f,\n                Wheel2 = 0.0f,\n                Wheel3 = 0.0f,\n                Wheel4 = 0.0f\n            };\n            commands.RobotCommands.Add(robotCommand);\n            grSimPacket.Commands = commands;\n\n\n            return grSimPacket.ToByteArray();\n        }\n\n        public void resetPacket(int roobot_id,int frequency)\n        {\n            this.robotID = roobot_id;\n            this.frequency = frequency; \n            this.velX = 0.0f;\n            this.velY = 0.0f;\n            this.velR = 0.0f;\n            this.ctrl = false;\n            this.shoot = false;\n            this.shootPowerLevel = 0;\n            this.useGlobleVel = true;\n            this.shootMode = false;\n\n        }\n\n        public void Encode() \n        {\n\n            string game_mode = Connect_Gate.GAME_MODE;\n            if (game_mode == Param.REAL)\n            {\n                Encode_Radio();\n            }\n            else if (game_mode == Param.SIMULATE) \n            {\n                this.transmitPacket = Encode_grSim();\n            }\n        \n        }\n        private void EncodeLegacy(Command command, byte[] TXBuff, int num)\n        {\n            int real_num = command.id;\n            int vx = (int)command.vx;\n            int vy = (int)command.vy;\n            int ivr = (int)command.vr;\n            int vr = Math.Min(Math.Abs(ivr), 511) * (ivr > 0 ? 1 : -1);\n            int power = (int)command.power;\n            bool kick_mode = command.kick_mode;\n            int dribble = (int)(command.dribble + 0.1f);\n\n            int vx_value_uint = Math.Abs(vx);\n            int vy_value_uint = Math.Abs(vy);\n            int w_value_uint = Math.Abs(vr);\n\n            if (real_num >= 8)\n            {\n                TXBuff[1] |= (byte)(0x01 << (real_num - 8));\n            }\n\n            if (real_num < 8)\n            {\n                TXBuff[2] |= (byte)(0x01 << real_num);\n            }\n\n            int baseIndex = 6 * num;\n            TXBuff[baseIndex + 3] = (byte)(0x01 | ((((kick_mode ? 0x01 : 0x00) << 2) | (0x03 & dribble)) << 4));\n\n            // vx\n            if (vx < 0)\n            {\n                TXBuff[baseIndex + 4] |= 0x20;\n            }\n            TXBuff[baseIndex + 4] |= (byte)((vx_value_uint & 0x1F0) >> 4);\n            TXBuff[baseIndex + 5] |= (byte)((vx_value_uint & 0x0F) << 4);\n\n            // vy\n            if (vy < 0)\n            {\n                TXBuff[baseIndex + 5] |= 0x08;\n            }\n            TXBuff[baseIndex + 5] |= (byte)((vy_value_uint & 0x1C0) >> 6);\n            TXBuff[baseIndex + 6] |= (byte)((vy_value_uint & 0x3F) << 2);\n\n            // vr\n            if (vr < 0)\n            {\n                TXBuff[baseIndex + 6] |= 0x02;\n            }\n            TXBuff[baseIndex + 6] |= (byte)((w_value_uint & 0x100) >> 8);\n            TXBuff[baseIndex + 7] |= (byte)(w_value_uint & 0xFF);\n\n            // shoot power\n            TXBuff[baseIndex + 8] = (byte)power;\n        }\n\n        private void CreateStartPacket(int frequency, out byte[] packet1, out byte[] packet2)\n        {\n            packet1 = new byte[Constants.TRANSMIT_PACKET_SIZE];\n            packet1[0] = 0xFF;\n            packet1[1] = 0xB0;\n            packet1[2] = 0x01;\n            packet1[3] = 0x02;\n            packet1[4] = 0x03;\n            packet1[Constants.TRANSMIT_PACKET_SIZE - 1] = ccrc.CCrc8.Calc(packet1, Constants.TRANSMIT_PACKET_SIZE - 1);\n\n            packet2 = new byte[Constants.TRANSMIT_PACKET_SIZE];\n            packet2[0] = 0xFF;\n            packet2[1] = 0xB0;\n            packet2[2] = 0x04;\n            packet2[3] = 0x05;\n            packet2[4] = 0x06;\n            packet2[5] = (byte)(0x10 + frequency);\n            packet2[Constants.TRANSMIT_PACKET_SIZE - 1] = ccrc.CCrc8.Calc(packet2, Constants.TRANSMIT_PACKET_SIZE - 1);\n        }\n    }\n\n\n\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Param\\Param.cs",
    "relative_path": "Param\\Param.cs",
    "file_name": "Param.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Param : MonoBehaviour\n{\n    static public string GAME_MODE;\n    static public string GAME_CONNECT_MODE;\n    // vision\n    static public string MCAST_GRP = \"224.5.23.2\"; // 视觉接收地址\n    static public int MCAST_PORT_SIM = 10020; // 视觉接收端口 仿真10020，实物10005\n    static public int MCAST_PORT_REAL = 10006; // 视觉接收端口 仿真10020，实物10005\n\n    static public float SCALE_COORDINATE = 0.01f;\n    // control\n\n    static public int MAX_POWER = 255;\n\n    static public float NROMAL_SPEED = 80f;\n    static public float SLOW_SPEED = 40f;\n    static public float MAX_SPEED = 200f;\n\n    static public int ROBOT_Z = 0;\n    static public int MAX_PLAYER = 16;\n    static public string BLUE = \"blue\";\n    static public string YELLOW = \"yellow\";\n    static public string ENEMY = \"enemy\";\n    static public string PLAYER = \"player\";\n    static public string SIMULATE = \"Simulate\";\n    static public string REAL = \"Real\";\n    static public float OUT_OF_SIGHT_Y = -10f; // Y坐标，表示机器人不在视野内\n    static public float CAMERA_SLOW_DISTANCE = 3f; // 摄像机 缓慢移动的距离\n    static public float DRIBBLE_BALL_DISTANCE = 1.8f;\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Param\\Robot.cs",
    "relative_path": "Param\\Robot.cs",
    "file_name": "Robot.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\npublic struct Robot\n{\n    public int id;\n    public Vector3 position;\n    public float dir;\n    public string team;\n\n    public static readonly Vector3 DefaultPosition = new UnityEngine.Vector3(0, -10, 10);\n\n\n    // 可选：构造函数，方便初始化\n    public Robot(float dir, string team, int id = default, Vector3 position = default)\n    {\n        this.id = id == default?-1: id;\n        this.position = position == default ? DefaultPosition : position;\n        this.dir = dir;\n        this.team = team;\n    }\n\n    public override string ToString()\n    {\n        return $\"Robot ID: {id}, Position: {position}, Direction: {dir}\";\n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\RefBox\\MulticastReceiver_RefBox.cs",
    "relative_path": "RefBox\\MulticastReceiver_RefBox.cs",
    "file_name": "MulticastReceiver_RefBox.cs",
    "content": "using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\nusing UnityEngine;\nusing Google.Protobuf;\nusing TMPro;\n\npublic class RefereeReceiver : MonoBehaviour\n{\n    private Socket refereeSocket;\n    public Referee referee_msg = null;\n    public TMP_Text ref_msg = null;\n    public GameObject ball_placement = null;\n    public string MCAST_GRP = \"224.5.23.1\";\n    public int MCAST_PORT = 10003;\n\n    void Start()\n    {\n        // 创建UDP套接字\n        refereeSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\n\n        // 设置地址重用\n        refereeSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n\n        // 绑定到0.0.0.0地址\n        EndPoint endPoint = new IPEndPoint(IPAddress.Any, MCAST_PORT);\n        refereeSocket.Bind(endPoint);\n\n        // 加入多播组\n        IPAddress multicastAddress = IPAddress.Parse(MCAST_GRP);\n        MulticastOption multicastOption = new MulticastOption(multicastAddress);\n        refereeSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership, multicastOption);\n\n        // 开始接收数据\n        Thread receiveThread = new Thread(ReceiveData);\n        receiveThread.IsBackground = true;\n        receiveThread.Start();\n    }\n\n    void Update()\n    {\n        // 如果有新的裁判信息，可以在这里处理\n        if (referee_msg != null)\n        {\n            ProcessRefereeMessage(referee_msg);\n            referee_msg = null;\n        }\n    }\n\n    void ReceiveData()\n    {\n        try\n        {\n            byte[] buffer = new byte[65535]; // 最大UDP数据包大小\n            EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n            while (true)\n            {\n                int bytesReceived = refereeSocket.ReceiveFrom(buffer, 0, buffer.Length, SocketFlags.None, ref remoteEndPoint);\n\n                if (bytesReceived > 0)\n                {\n                    byte[] data = new byte[bytesReceived];\n                    Array.Copy(buffer, data, bytesReceived);\n                    try\n                    {\n                        Referee newRefereeMsg = Referee.Parser.ParseFrom(data);\n\n                        // 使用锁来确保线程安全地更新 referee_msg\n                        lock (this)\n                        {\n                            referee_msg = newRefereeMsg;\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        Debug.LogError($\"Failed to parse referee packet: {ex.Message}\");\n                    }\n                }\n            }\n        }\n        catch (SocketException ex)\n        {\n            Debug.LogError(\"Socket error: \" + ex.Message);\n        }\n    }\n\n    void ProcessRefereeMessage(Referee msg)\n    {\n        // 打印当前命令\n        Debug.Log($\"Current Command: {msg.Command}\");\n        string command_str = msg.Command.ToString();\n        ref_msg.text = \"Ref Msg: \" + command_str;\n\n        // 检查是否有指定位置\n        if (msg.DesignatedPosition != null && (command_str == \"BallPlacementYellow\" || command_str == \"BallPlacementBlue\" ))\n        {\n            ball_placement.transform.position = new Vector3((float) msg.DesignatedPosition.X * Param.SCALE_COORDINATE, 0.07f, (float)msg.DesignatedPosition.Y * Param.SCALE_COORDINATE);\n        }\n        else \n        {\n            ball_placement.transform.position = new Vector3(0, -1f, 0);\n        }\n    }\n\n    void OnApplicationQuit()\n    {\n        // 退出时离开多播组并释放资源\n        if (refereeSocket != null)\n        {\n            refereeSocket.Close();\n            refereeSocket = null;\n        }\n    }\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Skill\\GetBall.cs",
    "relative_path": "Skill\\GetBall.cs",
    "file_name": "GetBall.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GetBall : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        \n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Skill\\GotoPos.cs",
    "relative_path": "Skill\\GotoPos.cs",
    "file_name": "GotoPos.cs",
    "content": "// Assets/Scripts/Skill/GotoPos.cs\nusing UnityEngine;\nusing System.Collections.Generic; // For Dictionary\n\npublic class GotoPos : MonoBehaviour\n{\n    // Store PID controllers for each robot and for each axis (X, Z, Orientation)\n    // We use a dictionary to map robotId to its set of PIDs\n    private Dictionary<int, PIDSet> robotPIDs = new Dictionary<int, PIDSet>();\n\n    // Helper class to store the three PIDs for a robot\n    private class PIDSet\n    {\n        public PIDController PidX { get; private set; }\n        public PIDController PidZ { get; private set; } // For Y-movement on XZ plane\n        public PIDController PidW { get; private set; } // For orientation (Yaw)\n\n        public PIDSet(PIDParams xParams, PIDParams zParams, PIDParams wParams)\n        {\n            PidX = new PIDController(xParams.Kp, xParams.Ki, xParams.Kd, xParams.MinOutput, xParams.MaxOutput);\n            PidZ = new PIDController(zParams.Kp, zParams.Ki, zParams.Kd, zParams.MinOutput, zParams.MaxOutput);\n            PidW = new PIDController(wParams.Kp, wParams.Ki, wParams.Kd, wParams.MinOutput, wParams.MaxOutput);\n        }\n    }\n\n    // Helper struct for PID parameters\n    public struct PIDParams\n    {\n        public float Kp, Ki, Kd;\n        public float MinOutput, MaxOutput;\n\n        public PIDParams(float p, float i, float d, float min, float max)\n        {\n            Kp = p; Ki = i; Kd = d;\n            MinOutput = min; MaxOutput = max;\n        }\n    }\n\n    // Example: Max speeds for clamping PID output\n    public float maxTranslationalSpeed = 200f; // e.g., units/sec, adjust based on Param.MAX_SPEED\n    public float maxAngularSpeed = 300f;       // e.g., deg/sec, adjust based on Control_Sim.maxRotationOutput\n\n    void Awake()\n    {\n        // Initialize PIDs for a specific robot (e.g., robot 0)\n        // You would typically get the robotID from Connect_Gate.robotID or iterate through all active robots\n        // These PID values are examples and WILL NEED TUNING.\n\n        // For X and Z (positional control)\n        PIDParams posParams = new PIDParams(\n            p: 100f,   // Proportional: higher means faster response, but can overshoot\n            i: 0.5f,   // Integral: helps eliminate steady-state error, but can cause windup\n            d: 5f,     // Derivative: dampens oscillations, stabilizes\n            min: -maxTranslationalSpeed,\n            max: maxTranslationalSpeed\n        );\n\n        // For W (angular control - orientation)\n        PIDParams rotParams = new PIDParams(\n            p: 150f,  // Proportional: higher means faster rotation\n            i: 1f,    // Integral\n            d: 10f,   // Derivative\n            min: -maxAngularSpeed,\n            max: maxAngularSpeed\n        );\n\n        // Example for robot ID 0 - in a real scenario, you might do this for Connect_Gate.robotID\n        // or loop through all possible robot IDs (0-15)\n        // For demonstration, let's assume we are controlling robot with ID from Connect_Gate\n        InitializePIDForRobot(Connect_Gate.robotID, posParams, posParams, rotParams);\n    }\n\n    /// <summary>\n    /// Initializes or reinitializes PID controllers for a given robot ID.\n    /// </summary>\n    public void InitializePIDForRobot(int robotId, PIDParams xParams, PIDParams zParams, PIDParams wParams)\n    {\n        if (!robotPIDs.ContainsKey(robotId))\n        {\n            robotPIDs[robotId] = new PIDSet(xParams, zParams, wParams);\n        }\n        else\n        {\n            // Optionally re-configure if needed, or just ensure they exist\n            robotPIDs[robotId].PidX.Kp = xParams.Kp;\n            robotPIDs[robotId].PidX.Ki = xParams.Ki;\n            robotPIDs[robotId].PidX.Kd = xParams.Kd;\n            // ... and so on for PidZ and PidW if you want to update existing ones\n        }\n    }\n\n\n    /// <summary>\n    /// Calculates the target velocities (world frame vx, world frame vz, angular vw)\n    /// for a given robot to reach a target position.\n    /// Note: The output velocities might need to be converted to the robot's local frame\n    /// depending on how your robot's control system (packet encoding) interprets them.\n    /// </summary>\n    /// <param name=\"robot\">The robot GameObject to control.</param>\n    /// <param name=\"targetPos\">The desired world position (Vector3).</param>\n    /// <param name=\"robotId\">The ID of the robot to get PIDs for.</param>\n    /// <param name=\"targetOrientation\">Optional: Desired final orientation (degrees). If NaN, face target.</param>\n    /// <returns>Vector3(world_vx, world_vz, angular_vw)</returns>\n    public Vector3 CalculateWorldVelocities(GameObject robot, Vector3 targetPos, int robotId, float targetOrientation = float.NaN)\n    {\n        if (robot == null || !robotPIDs.ContainsKey(robotId))\n        {\n            Debug.LogError($\"Robot or PIDSet for robot ID {robotId} not found.\");\n            return Vector3.zero;\n        }\n\n        PIDSet pids = robotPIDs[robotId];\n        Vector3 currentPos = robot.transform.position;\n        float currentOrientation = robot.transform.eulerAngles.y;\n\n        // --- Positional Control (X and Z axes in world frame) ---\n        // PID controllers output a \"control effort\". We interpret this as a desired velocity.\n        float world_vx = pids.PidX.Update(currentPos.x, targetPos.x, Time.deltaTime);\n        float world_vz = pids.PidZ.Update(currentPos.z, targetPos.z, Time.deltaTime);\n\n        // --- Rotational Control (W - angular velocity) ---\n        float finalTargetOrientation;\n        if (float.IsNaN(targetOrientation))\n        {\n            // If no specific orientation, face the target position\n            // Only calculate if not already very close to avoid spinning at the target\n            if (Vector3.Distance(new Vector3(currentPos.x, 0, currentPos.z), new Vector3(targetPos.x, 0, targetPos.z)) > 0.1f) // 10cm threshold\n            {\n                finalTargetOrientation = Mathf.Atan2(targetPos.x - currentPos.x, targetPos.z - currentPos.z) * Mathf.Rad2Deg;\n            }\n            else\n            {\n                finalTargetOrientation = currentOrientation; // Maintain current orientation if at target\n            }\n        }\n        else\n        {\n            finalTargetOrientation = targetOrientation;\n        }\n\n        float vw = pids.PidW.Update(currentOrientation, finalTargetOrientation, Time.deltaTime, true); // true for angle wrapping\n\n        return new Vector3(world_vx, world_vz, vw); // Note: Y component of Vector3 is used for Vz\n    }\n\n\n    /// <summary>\n    /// Calculates local velocities (local vx, local vy (which is vz on XZ plane), angular vw)\n    /// This is typically what grSim and similar robot control packets expect.\n    /// </summary>\n    /// <param name=\"robot\">The robot GameObject to control.</param>\n    /// <param name=\"targetPos\">The desired world position (Vector3).</param>\n    /// <param name=\"robotId\">The ID of the robot to get PIDs for.</param>\n    /// <param name=\"targetOrientation\">Optional: Desired final orientation (degrees). If NaN, face target.</param>\n    /// <returns>Vector3(local_vx, local_vy, angular_vw)</returns>\n    public Vector3 CalculateLocalVelocities(GameObject robot, Vector3 targetPos, int robotId, float targetOrientation = float.NaN)\n    {\n        Vector3 worldVels = CalculateWorldVelocities(robot, targetPos, robotId, targetOrientation);\n\n        // Transform world translational velocities to robot's local frame\n        Vector3 worldTranslationalVel = new Vector3(worldVels.x, 0, worldVels.y); // world_vx, 0, world_vz\n        Vector3 localTranslationalVel = robot.transform.InverseTransformDirection(worldTranslationalVel);\n\n        // Angular velocity (vw) is already around the robot's local Y axis\n        return new Vector3(localTranslationalVel.x, localTranslationalVel.z, worldVels.z);\n    }\n\n\n    // This is the function signature you provided in the original empty class.\n    // We'll adapt it to use the new structure.\n    // Let's assume it's for a specific robot (e.g., selfRobot from Vision)\n    // and it should return local velocities.\n    public Vector3 simpleToPos(GameObject robot, Vector3 targetPos)\n    {\n        // We need a robotId to fetch the correct PID parameters.\n        // This is a simplification. In a real system, you'd get this from game state.\n        // For now, let's try to infer it if it's one of the known player robots.\n        int robotId = -1;\n        for (int i = 0; i < Vision.player.Length; ++i)\n        {\n            if (Vision.player[i] == robot)\n            {\n                robotId = i;\n                break;\n            }\n        }\n        if (robotId == -1 && robot == Vision.selfRobot) // Check if it's the selfRobot specifically\n        {\n            robotId = Connect_Gate.robotID;\n        }\n\n\n        if (robotId != -1)\n        {\n            // If not initialized, initialize with default params (could happen if this is called before Awake/Start fully completes for some reason)\n            if (!robotPIDs.ContainsKey(robotId))\n            {\n                PIDParams posParams = new PIDParams(100f, 0.5f, 5f, -maxTranslationalSpeed, maxTranslationalSpeed);\n                PIDParams rotParams = new PIDParams(150f, 1f, 10f, -maxAngularSpeed, maxAngularSpeed);\n                InitializePIDForRobot(robotId, posParams, posParams, rotParams);\n            }\n            return CalculateLocalVelocities(robot, targetPos, robotId);\n        }\n        else\n        {\n            Debug.LogWarning($\"GotoPos.simpleToPos: Could not determine robotId for GameObject {robot.name}. Returning zero velocity.\");\n            return Vector3.zero;\n        }\n    }\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\utils\\KalmanFilter.cs",
    "relative_path": "utils\\KalmanFilter.cs",
    "file_name": "KalmanFilter.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class KalmanFilter\n{\n    public float[] Filter(float[] z)\n    {\n        float[] xhat = new float[z.Length];\n        xhat[0] = z[0];\n        float P = 1;\n\n        for (int k = 1; k < xhat.Length; k++)\n        {\n            float xhatminus = xhat[k - 1];\n            float Pminus = P + Q;\n            float K = Pminus / (Pminus + R);\n            xhat[k] = xhatminus + K * (z[k] - xhatminus);\n            P = (1 - K) * Pminus;\n        }\n        return xhat;\n    }\n\n    bool isFirst = true;\n    bool haveSetFirst = false;\n    float xhat;\n    float P;\n    float z0;\n    float Q = 1e-5f; // 0.00001\n    float R = 0.0001f;\n\n    public void SetFirst(float z0)\n    {\n        this.z0 = z0;\n        haveSetFirst = true;\n    }\n\n    // 理想誤差\n    public void SetQ(float Q)\n    {\n        this.Q = Q;\n    }\n\n    // 實際誤差\n    public void SetR(float R)\n    {\n        this.R = R;\n    }\n\n    public float Filter(float z1)\n    {\n        if (isFirst)\n        {\n            isFirst = false;\n            if (haveSetFirst == false) z0 = z1;\n            xhat = z0;\n            P = 1;\n        }\n\n        float xhatminus = xhat;\n        float Pminus = P + Q;\n        float K = Pminus / (Pminus + R);\n        xhat = xhatminus + K * (z1 - xhatminus);\n        P = (1 - K) * Pminus;\n\n        return xhat;\n    }\n\n    public void Reset()\n    {\n        isFirst = true;\n        haveSetFirst = false;\n        xhat = 0;\n        P = 0;\n        z0 = 0;\n        Q = 1e-5f; // 0.00001\n        R = 0.0001f;\n    }\n}\n\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\utils\\PID.cs",
    "relative_path": "utils\\PID.cs",
    "file_name": "PID.cs",
    "content": "using UnityEngine;\npublic class PIDRotation\n{\n    public float P = 0.5f;   // 调整比例增益\n    public float I = 0.0f;\n    public float D = 0.1f;   // 增加微分项抑制震荡\n\n    private float _integral;\n    private float _previousError;\n\n    public float Compute(float error, float deltaTime)\n    {\n        // 比例项\n        float proportional = P * error;\n\n        // 积分项（带限幅防止积分饱和）\n        _integral = Mathf.Clamp(_integral + error * deltaTime, -1, 1);\n        float integral = I * _integral;\n\n        // 微分项（使用误差变化率）\n        float derivative = D * ((error - _previousError) / deltaTime);\n        _previousError = error;\n\n        return proportional + integral + derivative;\n    }\n\n    public void Reset()\n    {\n        _integral = 0;\n        _previousError = 0;\n    }\n}\n\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\utils\\PIDController.cs",
    "relative_path": "utils\\PIDController.cs",
    "file_name": "PIDController.cs",
    "content": "// Assets/Scripts/utils/PIDController.cs\nusing UnityEngine;\n\npublic class PIDController\n{\n    public float Kp { get; set; }\n    public float Ki { get; set; }\n    public float Kd { get; set; }\n\n    private float integral;\n    private float previousError;\n\n    private float outputMin = -float.MaxValue;\n    private float outputMax = float.MaxValue;\n\n    public PIDController(float p, float i, float d, float minOut = -float.MaxValue, float maxOut = float.MaxValue)\n    {\n        Kp = p;\n        Ki = i;\n        Kd = d;\n        outputMin = minOut;\n        outputMax = maxOut;\n        integral = 0;\n        previousError = 0;\n    }\n\n    public void Reset()\n    {\n        integral = 0;\n        previousError = 0;\n    }\n\n    public float Update(float currentValue, float targetValue, float deltaTime, bool isAngle = false)\n    {\n        float error;\n        if (isAngle)\n        {\n            error = AngleDiff(targetValue, currentValue); // Target - Current for angles\n        }\n        else\n        {\n            error = targetValue - currentValue;\n        }\n\n        integral += error * deltaTime;\n        // Optional: Clamp integral to prevent windup\n        // integral = Mathf.Clamp(integral, -integralMax, integralMax); \n\n        float derivative = 0;\n        if (deltaTime > 0) // Avoid division by zero\n        {\n            derivative = (error - previousError) / deltaTime;\n        }\n\n        previousError = error;\n\n        float output = (Kp * error) + (Ki * integral) + (Kd * derivative);\n        return Mathf.Clamp(output, outputMin, outputMax);\n    }\n\n    /// <summary>\n    /// Calculates the shortest angle difference between two angles (a2 - a1).\n    /// Result is in the range [-180, 180].\n    /// </summary>\n    public static float AngleDiff(float a1Deg, float a2Deg)\n    {\n        float diff = a2Deg - a1Deg;\n        while (diff > 180f) diff -= 360f;\n        while (diff < -180f) diff += 360f;\n        return diff;\n    }\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\utils\\ProtoBufffer.cs",
    "relative_path": "utils\\ProtoBufffer.cs",
    "file_name": "ProtoBufffer.cs",
    "content": "using Google.Protobuf;\nusing System.Diagnostics;\npublic class ProtoBufffer\n{\n    public static byte[] Serialize(IMessage message)\n    {\n        return message.ToByteArray();\n    }\n\n    public static T DeSerialize<T>(byte[] packet) where T : IMessage, new()\n    {\n        IMessage message = new T();\n        try\n        {\n            return (T)message.Descriptor.Parser.ParseFrom(packet);\n        }\n        catch (System.Exception e)\n        {\n            \n            throw;\n        }\n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Vision\\Field.cs",
    "relative_path": "Vision\\Field.cs",
    "file_name": "Field.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Field : MonoBehaviour\n{\n    public GameObject field_plan;\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n    \n    // Update is called once per frame\n    void Update()\n    {\n        \n    }\n    void create_field(SSL_WrapperPacket packet)\n    {\n        var eometry_msg = packet.Geometry;\n\n    }\n}\n"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Vision\\MulticastReceiver.cs",
    "relative_path": "Vision\\MulticastReceiver.cs",
    "file_name": "MulticastReceiver.cs",
    "content": "using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\nusing UnityEngine;\nusing Google.Protobuf;\nusing static Packet;\n\npublic class MulticastReceiver : MonoBehaviour\n{\n\n    private Socket multicastSocket;\n    public SSL_WrapperPacket vision_packet_recive = null;\n    public SSL_WrapperPacket vision_packet = null;\n    static public SSL_WrapperPacket[] vision_packet_real = new SSL_WrapperPacket[4];\n\n    public string MCAST_GRP =  Param.MCAST_GRP;\n    public  int MCAST_PORT = (Connect_Gate.GAME_MODE == Param.REAL) ? Param.MCAST_PORT_REAL: Param.MCAST_PORT_SIM;\n\n\n    private const int NUM_ROBOTS = 16; // 每个队伍的机器人数量\n    private const int DISAPPEARANCE_THRESHOLD = 20; // 消失次数阈值\n    public GameObject ball_obj = null;\n    // 存储机器人GameObject的字典，提高查找效率\n    private Dictionary<string, GameObject> blueRobots = new Dictionary<string, GameObject>();\n    private Dictionary<string, GameObject> yellowRobots = new Dictionary<string, GameObject>();\n\n    // 存储机器人消失次数的字典\n    private Dictionary<string, int> blueDisappearanceCounts = new Dictionary<string, int>();\n    private Dictionary<string, int> yellowDisappearanceCounts = new Dictionary<string, int>();\n\n    void Start()\n    {\n        MCAST_PORT = (Connect_Gate.GAME_MODE == Param.REAL) ? Param.MCAST_PORT_REAL : Param.MCAST_PORT_SIM;\n        // 初始化机器人字典\n        InitializeRobots(blueRobots, \"blue_robot\");\n        InitializeRobots(yellowRobots, \"yellow_robot\");\n\n        // 初始化消失次数字典\n        InitializeDisappearanceCounts(blueDisappearanceCounts, \"blue_robot\");\n        InitializeDisappearanceCounts(yellowDisappearanceCounts, \"yellow_robot\");\n\n        ball_obj = GameObject.Find(\"Ball\");\n        // 创建UDP套接字\n        multicastSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\n\n        // 设置地址重用\n        multicastSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n\n        // 绑定到0.0.0.0地址\n        EndPoint endPoint = new IPEndPoint(IPAddress.Any, MCAST_PORT);\n        multicastSocket.Bind(endPoint);\n\n        // 加入多播组\n        IPAddress multicastAddress = IPAddress.Parse(MCAST_GRP);\n        MulticastOption multicastOption = new MulticastOption(multicastAddress);\n        multicastSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership, multicastOption);\n\n        // 开始接收数据\n        Thread receiveThread = new Thread(ReceiveData);\n        receiveThread.IsBackground = true;\n        receiveThread.Start();\n    }\n\n    // 初始化机器人字典\n    private void InitializeRobots(Dictionary<string, GameObject> robotDict, string robotPrefix)\n    {\n        for (int i = 0; i < NUM_ROBOTS; i++)\n        {\n            string obj_name = robotPrefix + i.ToString();\n            GameObject robot = GameObject.Find(obj_name);\n            if (robot != null)\n            {\n                robotDict.Add(obj_name, robot);\n            }\n            else\n            {\n                Debug.LogError($\"Robot GameObject not found: {obj_name}\");\n            }\n        }\n    }\n\n    // 初始化消失次数字典\n    private void InitializeDisappearanceCounts(Dictionary<string, int> disappearanceCounts, string robotPrefix)\n    {\n        for (int i = 0; i < NUM_ROBOTS; i++)\n        {\n            string obj_name = robotPrefix + i.ToString();\n            disappearanceCounts.Add(obj_name, 0);\n        }\n    }\n\n    void Update()\n    {\n        \n        for(int i = 0; i < 4; i++) \n        {\n            if (vision_packet_real[i] != null) \n            {\n                ProcessPacket(vision_packet_real[i]);\n                vision_packet_real[i] = null;\n            }\n        \n        }\n\n    }\n\n    void ReceiveData()\n    {\n        try\n        {\n            byte[] buffer = new byte[65535]; // 最大UDP数据包大小\n            EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n            while (true)\n            {\n                \n                int bytesReceived = multicastSocket.ReceiveFrom(buffer, 0, buffer.Length, SocketFlags.None, ref remoteEndPoint);\n                // 将接收到的字节数组反序列化为SSL_WrapperPacket\n                if (bytesReceived > 0)\n                {\n                    byte[] data = new byte[bytesReceived];\n                    Array.Copy(buffer, data, bytesReceived);\n                    try\n                    {\n                        SSL_WrapperPacket newPacket = SSL_WrapperPacket.Parser.ParseFrom(data);\n                        // 使用锁来确保线程安全地更新 vision_packet\n                        lock (this)\n                        {\n                            vision_packet = newPacket;\n                            vision_packet_real[vision_packet.Detection.CameraId] = newPacket;\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        Debug.LogError($\"Failed to parse packet: {ex.Message}\");\n                    }\n                }\n            }\n        }\n        catch (SocketException ex)\n        {\n            Debug.LogError(\"Socket error: \" + ex.Message);\n        }\n    }\n\n    void ProcessPacket(SSL_WrapperPacket packet)\n    {\n        // 处理检测数据\n        if (packet.Detection != null)\n        {\n            // 创建HashSet来快速查找当前帧中存在的机器人ID\n            HashSet<uint> detectedBlueIds = new HashSet<uint>();\n            HashSet<uint> detectedYellowIds = new HashSet<uint>();\n            foreach (var ball in packet.Detection.Balls) \n            {\n                float x = ball.X * Param.SCALE_COORDINATE;\n                float y = ball.Y * Param.SCALE_COORDINATE;\n                ball_obj.transform.position = new UnityEngine.Vector3(x, -0.5f, y);\n            }\n            // 处理蓝色机器人\n            foreach (var robot_blue in packet.Detection.RobotsBlue)\n            {\n\n                uint id = robot_blue.RobotId;\n                detectedBlueIds.Add(id);\n                float x = robot_blue.X * Param.SCALE_COORDINATE;\n                float y = robot_blue.Y * Param.SCALE_COORDINATE;\n                //float dir = -robot_blue.Orientation * Mathf.Rad2Deg;\n                float dir = -(robot_blue.Orientation + Mathf.PI / 2) * Mathf.Rad2Deg;\n\n                string obj_name = \"blue_robot\" + id.ToString();\n                if (blueRobots.ContainsKey(obj_name))\n                {\n\n                    blueRobots[obj_name].transform.position = new UnityEngine.Vector3(x, 0, y);\n                    blueRobots[obj_name].transform.rotation = UnityEngine.Quaternion.Euler(0, dir, 0);\n                    blueDisappearanceCounts[obj_name] = 0; // 重置消失计数器\n                }\n                else\n                {\n                    Debug.LogWarning($\"Robot GameObject not found in dictionary: {obj_name}\");\n                }\n            }\n\n            // 处理黄色机器人\n            foreach (var robot_yellow in packet.Detection.RobotsYellow)\n            {\n                uint id = robot_yellow.RobotId;\n                detectedYellowIds.Add(id);\n                float x = robot_yellow.X * Param.SCALE_COORDINATE;\n                float y = robot_yellow.Y * Param.SCALE_COORDINATE;\n                float dir = -(robot_yellow.Orientation + Mathf.PI / 2) * Mathf.Rad2Deg;\n\n                string obj_name = \"yellow_robot\" + id.ToString();\n\n                if (yellowRobots.ContainsKey(obj_name))\n                {\n                    yellowRobots[obj_name].transform.position = new UnityEngine.Vector3(x, Param.ROBOT_Z, y);\n                    yellowRobots[obj_name].transform.rotation = UnityEngine.Quaternion.Euler(0, dir, 0);\n                    //Debug.Log($\"{dir}\");\n                    \n                    yellowDisappearanceCounts[obj_name] = 0; // 重置消失计数器\n                }\n                else\n                {\n                    Debug.LogWarning($\"Robot GameObject not found in dictionary: {obj_name}\");\n                }\n            }\n\n            // 处理未检测到的蓝色机器人\n            for (int i = 0; i < NUM_ROBOTS; i++)\n            {\n                string obj_name = \"blue_robot\" + i.ToString();\n                if (!detectedBlueIds.Contains((uint)i))\n                {\n                    blueDisappearanceCounts[obj_name]++; // 增加消失计数器\n                    if (blueDisappearanceCounts[obj_name] > DISAPPEARANCE_THRESHOLD)\n                    {\n                        if (blueRobots.ContainsKey(obj_name))\n                        {\n                            blueRobots[obj_name].transform.position = new UnityEngine.Vector3(0, Param.OUT_OF_SIGHT_Y, 0);\n                        }\n                    }\n                }\n            }\n\n            // 处理未检测到的黄色机器人\n            for (int i = 0; i < NUM_ROBOTS; i++)\n            {\n                string obj_name = \"yellow_robot\" + i.ToString();\n                if (!detectedYellowIds.Contains((uint)i))\n                {\n                    yellowDisappearanceCounts[obj_name]++; // 增加消失计数器\n                    if (yellowDisappearanceCounts[obj_name] > DISAPPEARANCE_THRESHOLD)\n                    {\n                        if (yellowRobots.ContainsKey(obj_name))\n                        {\n                            yellowRobots[obj_name].transform.position = new UnityEngine.Vector3(0, Param.OUT_OF_SIGHT_Y, 0);\n                        }\n                    }\n                }\n            }\n        }\n\n        // 处理几何数据\n        if (packet.Geometry != null)\n        {\n            Debug.Log(packet.Geometry);\n            // 在这里处理Geometry数据\n        }\n    }\n\n    void OnApplicationQuit()\n    {\n        // 退出时离开多播组并释放资源\n        if (multicastSocket != null)\n        {\n            multicastSocket.Close();\n            multicastSocket = null;\n        }\n    }\n}"
  },
  {
    "file_path": "D:\\MyGme\\cuddly-fiesta\\Assets\\Scripts\\Vision\\Vision.cs",
    "relative_path": "Vision\\Vision.cs",
    "file_name": "Vision.cs",
    "content": "using System.Collections;\nusing System.Collections.Generic;\nusing Unity.VisualScripting;\nusing UnityEngine;\n\npublic class Vision : MonoBehaviour\n{\n\n    static public GameObject selfRobot = null;\n    static public GameObject ball = null;\n    static public GameObject[] player = new GameObject[Param.MAX_PLAYER];\n    static public GameObject[] enemy = new GameObject[Param.MAX_PLAYER];\n    static public GameObject mouseObj = null;\n\n    void Awake()\n    {\n        string enemy_team = Connect_Gate.team == Param.BLUE ? Param.BLUE : Param.YELLOW;\n        ball = GameObject.Find(\"Ball\");\n        selfRobot = GameObject.Find(Connect_Gate.team + \"_robot\" + Connect_Gate.robotID.ToString());\n        mouseObj = GameObject.Find(\"target\");\n        for (int i = 0; i < Param.MAX_PLAYER; i++)\n        {\n            player[i] =  GameObject.Find(Connect_Gate.team + \"_robot\" + i.ToString());\n            enemy[i] = GameObject.Find(enemy_team + \"_robot\" + i.ToString());\n        }\n    }\n    void Update()\n    { \n    \n    \n    }\n        static public GameObject FindNearestObjectInRange(Vector3 position, float radius)\n    {\n        return ball;\n    }\n\n\n    static public bool isValid(int num,string enemy_or_player = \"player\")\n    {\n        \n        if (enemy_or_player == Param.ENEMY)\n        {\n            return (enemy[num].transform.position[1] == Param.OUT_OF_SIGHT_Y)?true:false;\n        }\n        else\n        {\n            return (player[num].transform.position[1] == Param.OUT_OF_SIGHT_Y) ? true : false;\n        }\n\n    }\n    static public bool isEnemy(string team)\n    {\n        return Connect_Gate.team != team;\n\n    }\n\n}\n"
  }
]